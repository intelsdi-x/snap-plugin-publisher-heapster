/*
http://www.apache.org/licenses/LICENSE-2.0.txt


Copyright 2016 Intel Corporation

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Package jsonutil offers utilities for building and traversing composite
// objects reconstructed from metrics.
package jsonutil

import (
	"encoding/json"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
	"time"
)

// JSONWalker is a utility offering recursive traversal of composite map
// objects.
type JSONWalker struct {
	fs interface{}
}

// ObjectPath is a form of representation for namespaces, supports ordering by
// path length in first place (function Diff)
type ObjectPath struct {
	Literal string
	Split   []string
}

// objectPaths implements Interface from sort package.
type objectPaths []ObjectPath

// dummyFileInfo implements os.FileInfo to facilitate walking object
// structure the way filesystem may be explored.
type dummyFileInfo struct {
	name  string
	isDir bool
	sys   interface{}
}

// MetricHandle is a type representing metric item for building it into
// structures
type MetricHandle interface {
	// Path reports path of the metric that indicates namespace of the
	// metric
	Path() ObjectPath
	// Data reports the value carried by metric
	Data() interface{}
	// RawMetric returns the raw metric type that should be exposed to
	// other systems
	RawMetric() interface{}
}

// MetricList is a type of metrics that may be passed for parsing
type MetricList interface {
	// Len returns number of items in the list
	Len() int
	// Item returns a metric item in the list
	Item(index int) MetricHandle
}

// JSONCodec wraps most commonly used JSON operations
type JSONCodec interface {
	// Unmarshal decodes raw byte data into destination object
	Unmarshal(raw []byte, dest interface{}) error
	// Encode transforms object into its JSON representation
	Encode(writer io.Writer, obj interface{}) error
}

// StdJSONCodec is a standard-package based JSONCodec implementation
type StdJSONCodec struct{}

// Unmarshal decodes raw byte data into destination object
func (c *StdJSONCodec) Unmarshal(raw []byte, dest interface{}) error {
	return json.Unmarshal(raw, dest)
}

// Encode transforms object into its JSON representation
func (c *StdJSONCodec) Encode(writer io.Writer, obj interface{}) error {
	encoder := json.NewEncoder(writer)
	return encoder.Encode(obj)
}

// NewObjectPath creates a new objectpath from
func NewObjectPath(literal string) *ObjectPath {
	split := strings.Split(strings.Trim(literal, "/"), "/")
	return &ObjectPath{Literal: literal, Split: split}
}

// Len fulfills Interface from sort package.
func (p objectPaths) Len() int {
	return len(p)
}

// Swap fulfills Interface from sort package.
func (p objectPaths) Swap(i, j int) {
	p[i], p[j] = p[j], p[i]
}

// Diff compares objectPath to another instance, considering path length order
// first (ASC) and then lexicographical comparison (ASC) of path segments.
func (o ObjectPath) Diff(p ObjectPath) int {
	l := o.Split
	r := p.Split
	ll := len(l)
	lr := len(r)
	if ll != lr {
		return ll - lr
	}
	for k := 0; k < ll && k < lr; k++ {
		if diff := strings.Compare(l[k], r[k]); diff != 0 {
			return diff
		}
	}
	return 0
}

// Less fulfills Interface from sort package, putting shortest paths first. Equal
// paths are not considered less.
func (p objectPaths) Less(i, j int) bool {
	l, r := p[i], p[j]
	return l.Diff(r) < 0
}

// RebuildObjectFromMetrics builds a composite object of metrics.
// Constructed object reflects the structure of namespace, with leaves generated by user
// callback function.
func RebuildObjectFromMetrics(metrics MetricList, generator func(path []string, metric MetricHandle) interface{}) map[string]interface{} {
	resObj := map[string]interface{}{}
	// mkdir creates intermediate objects to have valid object path, returning target object
	// at the input path and number of segments that were created along the path
	var mkdir func([]string, map[string]interface{}) map[string]interface{}
	mkdir = func(path []string, target map[string]interface{}) map[string]interface{} {
		if len(path) == 0 {
			return target
		}
		child, haveChild := target[path[0]]
		if !haveChild {
			child = map[string]interface{}{}
			target[path[0]] = child
		}
		if len(path) > 1 {
			res := mkdir(path[1:], child.(map[string]interface{}))
			return res
		}
		return child.(map[string]interface{})
	}
	snapshot := map[string]MetricHandle{}
	// extract list of paths for sorting
	var paths objectPaths
	for i := 0; i < metrics.Len(); i++ {
		m := metrics.Item(i)
		snapshot[m.Path().Literal] = m
		paths = append(paths, m.Path())
	}
	// sort the paths with shortest in front
	sorted := objectPaths(paths)
	sort.Sort(sorted)
	for _, path := range paths {
		parent, leaf := path.Split[:len(path.Split)-1], path.Split[len(path.Split)-1]
		target := mkdir(parent, resObj)
		value := generator(path.Split, snapshot[path.Literal])
		target[leaf] = value
	}
	return resObj
}

// PruneEmptySubtrees prunes empty branches in tree, traversed in DFS order.
func PruneEmptySubtrees(tree map[string]interface{}) {
	var pruneSubtree func(parent map[string]interface{}, key string)
	pruneSubtree = func(parent map[string]interface{}, key string) {
		if subtree, isMap := parent[key].(map[string]interface{}); isMap {
			for k := range subtree {
				pruneSubtree(subtree, k)
			}
			if len(subtree) == 0 {
				delete(parent, key)
			}
		}
	}
	for k := range tree {
		pruneSubtree(tree, k)
	}
}

// NewObjWalker returns an iterator over contents of a composite object.
//
// Iterator provided by NewObjWalker supports the same semantics as standard
// `filepath.Walk`.
//
// The only nodes that can be inspected in depth are generic map and generic
// array, namely `map[string]interface{}` and `[]interface{}`.
func NewObjWalker(root interface{}) *JSONWalker {
	walker := new(JSONWalker)
	walker.fs = root
	return walker
}

// Walk implements similar behavior to `filepath.Walk`.
// In case given path couldn't be reached, function returns error containing
// that path.
func (w *JSONWalker) Walk(path string, walkFunc filepath.WalkFunc) error {
	node, err := seek(w.fs, path)
	if err != nil {
		return err
	}
	walk(node, path, walkFunc)
	return nil
}

// Seek walks through walker's target object until specific path is reached,
// returning handle to data at that location.
//
// Seek tries its best to find value at given path. Failure to reach the path
// is indicated with an error containing the path.
func (w *JSONWalker) Seek(seekPath string) (interface{}, error) {
	return seek(w.fs, seekPath)
}

// Name fulfills os.FileInfo interface for nodes in composite object
func (i *dummyFileInfo) Name() string {
	return i.name
}

// IsDir fulfills os.FileInfo interface for nodes in composite object
func (i *dummyFileInfo) IsDir() bool {
	return i.isDir
}

// Size fulfills os.FileInfo interface for nodes in composite object
func (i *dummyFileInfo) Size() int64 {
	return 0
}

// Mode fulfills os.FileInfo interface for nodes in composite object
func (i *dummyFileInfo) Mode() os.FileMode {
	if i.isDir {
		return os.ModeDir
	}
	return 0
}

// ModTime fulfills os.FileInfo interface for nodes in composite object
func (i *dummyFileInfo) ModTime() time.Time {
	return time.Time{}
}

// Sys fulfills os.FileInfo interface for nodes in composite object, exposing
// underlying data item directly.
func (i *dummyFileInfo) Sys() interface{} {
	return i.sys
}

func seek(root interface{}, seekPath string) (interface{}, error) {
	var result interface{}
	resultSet := false
	walk(root, "/", func(path string, info os.FileInfo, _ error) error {
		if result != nil {
			return filepath.SkipDir
		} else if path == seekPath {
			result = info.Sys()
			resultSet = true
			return filepath.SkipDir
		}
		return nil
	})
	if resultSet {
		return result, nil
	}
	return nil, fmt.Errorf("jsonutil: couldn't seek to path '%s' - path not found", seekPath)
}

func basename(path string) string {
	base := filepath.Base(path)
	if base == "." {
		return "/"
	}
	return base
}

func walk(node interface{}, path string, walkFunc filepath.WalkFunc) error {
	var err error
	if dirNode, isDir := node.(map[string]interface{}); isDir {
		err = walkFunc(path, &dummyFileInfo{basename(path), true, dirNode}, nil)
		if err == filepath.SkipDir {
			return nil
		}
		for k, subNode := range dirNode {
			err = walk(subNode, filepath.Join(path, k), walkFunc)
			if err == filepath.SkipDir {
				return nil
			}
		}
	} else if dirNode, isDir := node.([]interface{}); isDir {
		err = walkFunc(path, &dummyFileInfo{basename(path), true, dirNode}, nil)
		if err == filepath.SkipDir {
			return nil
		}
		for k, subNode := range dirNode {
			err = walk(subNode, filepath.Join(path, strconv.Itoa(k)), walkFunc)
			if err == filepath.SkipDir {
				return nil
			}
		}
	} else {
		err = walkFunc(path, &dummyFileInfo{basename(path), false, node}, nil)
		if err == filepath.SkipDir {
			return err
		}
	}
	return nil
}
