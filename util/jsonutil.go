/*
http://www.apache.org/licenses/LICENSE-2.0.txt


Copyright 2016 Intel Corporation

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or  implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package util

import (
	"errors"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/intelsdi-x/snap/control/plugin"
)

type JsonWalker struct {
	fs interface{}
}

// objectPaths supports shortest-first ordering
type objectPath struct {
	Literal string
	Split   []string
}
type objectPaths []objectPath

type dummyFileInfo struct {
	name  string
	isDir bool
	sys   interface{}
}

var NotFound = errors.New("Path not found")

func (p objectPaths) Len() int {
	return len(p)
}

func (p objectPaths) Swap(i, j int) {
	p[i], p[j] = p[j], p[i]
}

func (p objectPaths) Less(i, j int) bool {
	l, r := p[i], p[j]
	diff := func(l, r []string) int {
		ll := len(l)
		lr := len(r)
		if ll != lr {
			return ll - lr
		}
		for k := 0; k < ll && k < lr; k++ {
			if diff := strings.Compare(l[k], r[k]); diff != 0 {
				return diff
			}
		}
		return 0
	}
	return diff(l.Split, r.Split) <= 0
}

// RebuildObjectFromMetrics  builds a composite object of metrics.
// Constructed object reflects the structure of namespace, with leaves generated by user
// callback function.
func RebuildObjectFromMetrics(metrics []plugin.MetricType, generator func(path []string, metric plugin.MetricType) interface{}) map[string]interface{} {
	resObj := map[string]interface{}{}
	// mkdir creates intermediate objects to have valid object path, returning target object
	// at the input path and number of segments that were created along the path
	var mkdir func([]string, map[string]interface{}) map[string]interface{}
	mkdir = func(path []string, target map[string]interface{}) map[string]interface{} {
		if len(path) == 0 {
			return target
		}
		child, haveChild := target[path[0]]
		if !haveChild {
			child = map[string]interface{}{}
			target[path[0]] = child
		}
		if len(path) > 1 {
			res := mkdir(path[1:], child.(map[string]interface{}))
			return res
		}
		return child.(map[string]interface{})
	}
	snapshot := map[string]plugin.MetricType{}
	// extract list of paths for sorting
	var paths objectPaths
	for _, m := range metrics {
		path := strings.TrimLeft(m.Namespace().String(), "/")
		snapshot[path] = m
		paths = append(paths, objectPath{Literal: path, Split: m.Namespace().Strings()})
	}
	// sort the paths with shortest in front
	sorted := objectPaths(paths)
	sort.Sort(sorted)
	for _, path := range paths {
		parent, leaf := path.Split[:len(path.Split)-1], path.Split[len(path.Split)-1]
		target := mkdir(parent, resObj)
		value := generator(path.Split, snapshot[path.Literal])
		target[leaf] = value
	}
	return resObj
}

func PruneEmptySubtrees(tree map[string]interface{}) {
	var pruneSubtree func(parent map[string]interface{}, key string)
	pruneSubtree = func(parent map[string]interface{}, key string) {
		if subtree, isMap := parent[key].(map[string]interface{}); isMap {
			for k := range subtree {
				pruneSubtree(subtree, k)
			}
			if len(subtree) == 0 {
				delete(parent, key)
			}
		}
	}
	for k := range tree {
		pruneSubtree(tree, k)
	}
}

// NewObjWalker returns an iterator over contents of a composite object.
//
// Iterator provided by NewObjWalker supports the same semantics as standard
// `filepath.Walk`.
//
// The only nodes that can be inspected in depth are generic map and generic
// array, namely `map[string]interface{}` and `[]interface{}`.
func NewObjWalker(root interface{}) *JsonWalker {
	walker := new(JsonWalker)
	walker.fs = root
	return walker
}

// Walk implements similar behavior to `filepath.Walk`.
func (w *JsonWalker) Walk(path string, walkFunc filepath.WalkFunc) error {
	node, err := seek(w.fs, path)
	if err != nil {
		return err
	}
	walk(node, path, walkFunc)
	return nil
}

// Seek walks through walker's target object until specific path is reached,
// returning handle to data at that location.
//
// Seek tries its best to find value at given path. Failure to reach the path
// is indicated with error value of `NotFound`.
func (w *JsonWalker) Seek(seekPath string) (interface{}, error) {
	return seek(w.fs, seekPath)
}

func (i *dummyFileInfo) Name() string {
	return i.name
}

func (i *dummyFileInfo) IsDir() bool {
	return i.isDir
}

func (i *dummyFileInfo) Size() int64 {
	return 0
}

func (i *dummyFileInfo) Mode() os.FileMode {
	if i.isDir {
		return os.ModeDir
	}
	return 0
}

func (i *dummyFileInfo) ModTime() time.Time {
	return time.Time{}
}

func (i *dummyFileInfo) Sys() interface{} {
	return i.sys
}

func seek(root interface{}, seekPath string) (interface{}, error) {
	var result interface{}
	resultSet := false
	walk(root, "/", func(path string, info os.FileInfo, _ error) error {
		if result != nil {
			return filepath.SkipDir
		} else if path == seekPath {
			result = info.Sys()
			resultSet = true
			return filepath.SkipDir
		}
		return nil
	})
	if resultSet {
		return result, nil
	}
	return nil, NotFound
}

func basename(path string) string {
	base := filepath.Base(path)
	if base == "." {
		return "/"
	}
	return base
}

func walk(node interface{}, path string, walkFunc filepath.WalkFunc) error {
	var err error
	if dirNode, isDir := node.(map[string]interface{}); isDir {
		err = walkFunc(path, &dummyFileInfo{basename(path), true, dirNode}, nil)
		if err == filepath.SkipDir {
			return nil
		}
		for k, subNode := range dirNode {
			err = walk(subNode, filepath.Join(path, k), walkFunc)
			if err == filepath.SkipDir {
				return nil
			}
		}
	} else if dirNode, isDir := node.([]interface{}); isDir {
		err = walkFunc(path, &dummyFileInfo{basename(path), true, dirNode}, nil)
		if err == filepath.SkipDir {
			return nil
		}
		for k, subNode := range dirNode {
			err = walk(subNode, filepath.Join(path, strconv.Itoa(k)), walkFunc)
			if err == filepath.SkipDir {
				return nil
			}
		}
	} else {
		err = walkFunc(path, &dummyFileInfo{basename(path), false, node}, nil)
		if err == filepath.SkipDir {
			return err
		}
	}
	return nil
}
